# -*- coding: utf-8 -*-

"""
/***************************************************************************
 LeastCostPath
                                 A QGIS plugin
 Find the least cost path with given cost raster and points
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-12-12
        copyright            : (C) 2018 by FlowMap Group@SESS.PKU
        email                : xurigong@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'FlowMap Group@SESS.PKU'
__date__ = '2018-12-12'
__copyright__ = '(C) 2018 by FlowMap Group@SESS.PKU'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from PyQt5.QtCore import QCoreApplication, QVariant
from qgis.core import (
    QgsFeature,
    QgsGeometry,
    QgsPoint,
    QgsField,
    QgsFields,
    QgsWkbTypes,
    QgsProcessing,
    QgsFeatureSink,
    QgsProcessingException,
    QgsProcessingAlgorithm,
    QgsProcessingParameterFeatureSource,
    QgsProcessingParameterFeatureSink,
    QgsProcessingParameterRasterLayer,
    QgsProcessingParameterBand,
    QgsProcessingParameterRasterDestination)
import processing
from math import floor
import queue


class LeastCostPathAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    INPUT_COST_RASTER = 'INPUT_COST_RASTER'
    INPUT_RASTER_BAND = 'INPUT_RASTER_BAND'
    INPUT_START_LAYER = 'INPUT_START_LAYER'
    INPUT_END_LAYER = 'INPUT_END_LAYER'
    OUTPUT = 'OUTPUT'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT_COST_RASTER,
                self.tr('Cost raster layer'),
            )
        )

        self.addParameter(
            QgsProcessingParameterBand(
                self.INPUT_RASTER_BAND,
                self.tr('Cost raster band'),
                0,
                self.INPUT_COST_RASTER,
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT_START_LAYER,
                self.tr('Start-point layer'),
                [QgsProcessing.TypeVectorPoint]
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT_END_LAYER,
                self.tr('End-point(s) layer'),
                [QgsProcessing.TypeVectorPoint]
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Output layer')
            )
        )


    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # Retrieve the feature source and sink. The 'dest_id' variable is used
        # to uniquely identify the feature sink, and must be included in the
        # dictionary returned by the processAlgorithm function.

        cost_raster = self.parameterAsRasterLayer(
            parameters,
            self.INPUT_COST_RASTER,
            context
        )

        cost_raster_band = self.parameterAsInt(
            parameters,
            self.INPUT_RASTER_BAND,
            context
        )

        start_source = self.parameterAsSource(
            parameters,
            self.INPUT_START_LAYER,
            context
        )

        end_source = self.parameterAsSource(
            parameters,
            self.INPUT_END_LAYER,
            context
        )

        # If source was not found, throw an exception to indicate that the algorithm
        # encountered a fatal error. The exception text can be any string, but in this
        # case we use the pre-built invalidSourceError method to return a standard
        # helper text for when a source cannot be evaluated
        if cost_raster is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT_COST_RASTER))
        if cost_raster_band is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT_RASTER_BAND))
        if start_source is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT_START_LAYER))
        if end_source is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT_START_LAYER))

        if cost_raster.crs() != start_source.sourceCrs() \
                or start_source.sourceCrs() != end_source.sourceCrs():
            raise QgsProcessingException("ERROR: The input layers have different CRSs.")

        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            start_source.fields(),
            QgsWkbTypes.LineString,
            cost_raster.crs(),
        )

        # Send some information to the user
        feedback.pushInfo('CRS is {}'.format(cost_raster.crs().authid()))

        # If sink was not created, throw an exception to indicate that the algorithm
        # encountered a fatal error. The exception text can be any string, but in this
        # case we use the pre-built invalidSinkError method to return a standard
        # helper text for when a sink cannot be evaluated
        if sink is None:
            raise QgsProcessingException(self.invalidSinkError(parameters, self.OUTPUT))

        start_features = list(start_source.getFeatures())
        # feedback.pushInfo(str(len(start_features)))
        start_col_rows = MinCostPathHelper.features_to_row_cols(start_features, cost_raster)
        if len(start_col_rows) == 0:
            raise QgsProcessingException("ERROR: The start-point layer contains no legal point.")
        elif len(start_col_rows) >= 2:
            raise QgsProcessingException("ERROR: The start-point layer contains more than one legal point.")

        end_features = list(end_source.getFeatures())
        # feedback.pushInfo(str(len(end_features)))
        end_col_rows = MinCostPathHelper.features_to_row_cols(end_features, cost_raster)
        if len(end_col_rows) == 0:
            raise QgsProcessingException("ERROR: The end-point layer contains no legal point.")

        # feedback.pushInfo(str(start_col_rows))
        # feedback.pushInfo(str(end_col_rows))

        block = MinCostPathHelper.get_all_block(cost_raster, cost_raster_band)
        matrix, contains_negative = MinCostPathHelper.block2matrix(block)
        feedback.pushInfo("The size of cost raster is: " + str(block.height()) + ' * ' + str(block.width()))

        if contains_negative:
            raise QgsProcessingException("ERROR: Cost raster contains negative value.")

        min_cost_path, cost = MinCostPathHelper. \
            dijkstra(start_col_rows[0], end_col_rows, matrix)
        # feedback.pushInfo(str(min_cost_path))

        if min_cost_path is None:
            raise QgsProcessingException("ERROR: There is no reasonable path between start-point and end-point(s)")

        path_feature = MinCostPathHelper. \
            create_path_feature(cost_raster, min_cost_path, cost)
        sink.addFeature(path_feature, QgsFeatureSink.FastInsert)
        return {self.OUTPUT: dest_id}

    
    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Least Cost Path'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return LeastCostPathAlgorithm()

    
class MinCostPathHelper:
    @staticmethod
    def _point_to_row_col(pointxy, raster_layer):
        xres = raster_layer.rasterUnitsPerPixelX()
        yres = raster_layer.rasterUnitsPerPixelY()
        extent = raster_layer.dataProvider().extent()

        col = floor((pointxy.x() - extent.xMinimum()) / xres)
        row = floor((extent.yMaximum() - pointxy.y()) / yres)

        return row, col

    @staticmethod
    def _row_col_to_point(row_col, raster_layer):
        xres = raster_layer.rasterUnitsPerPixelX()
        yres = raster_layer.rasterUnitsPerPixelY()
        extent = raster_layer.dataProvider().extent()

        x = (row_col[1] + 0.5) * xres + extent.xMinimum()
        y = extent.yMaximum() - (row_col[0] + 0.5) * yres
        return QgsPoint(x, y)

    @staticmethod
    def create_path_feature(cost_raster, row_cols, total_cost):
        points = map(lambda row_col: MinCostPathHelper._row_col_to_point(row_col, cost_raster), row_cols)
        polyline = QgsGeometry.fromPolyline(points)
        cost_field = QgsField("total cost", QVariant.Double, "double", 10, 3)
        fields = QgsFields()
        fields.append(cost_field, 0)
        feature = QgsFeature(fields)
        # feature.setAttribute(0, 1) # id
        cost_index = feature.fieldNameIndex("total cost")
        feature.setAttribute(cost_index, total_cost)  # cost
        feature.setGeometry(polyline)
        return feature

    @staticmethod
    def features_to_row_cols(point_features, raster_layer):
        row_cols = set()
        extent = raster_layer.dataProvider().extent()
        # if extent.isNull() or extent.isEmpty:
        #     return list(col_rows)

        for point_feature in point_features:
            if point_feature.hasGeometry():

                point_geom = point_feature.geometry()
                if point_geom.wkbType() == QgsWkbTypes.MultiPoint:
                    multi_points = point_geom.asMultiPoint()
                    for pointxy in multi_points:
                        if extent.contains(pointxy):
                            row_cols.add(MinCostPathHelper._point_to_row_col(pointxy, raster_layer))

                elif point_geom.wkbType() == QgsWkbTypes.Point:
                    pointxy = point_geom.asPoint()
                    if extent.contains(pointxy):
                        row_cols.add(MinCostPathHelper._point_to_row_col(pointxy, raster_layer))

        return list(row_cols)

    @staticmethod
    def get_all_block(raster_layer, band_num):
        provider = raster_layer.dataProvider()
        extent = provider.extent()

        xres = raster_layer.rasterUnitsPerPixelX()
        yres = raster_layer.rasterUnitsPerPixelY()
        width = floor((extent.xMaximum() - extent.xMinimum()) / xres)
        height = floor((extent.yMaximum() - extent.yMinimum()) / yres)
        return provider.block(band_num, extent, width, height)

    @staticmethod
    def block2matrix(block):
        contains_negative = False
        matrix = [[None if block.isNoData(i, j) else block.value(i, j)
                   for j in range(block.width())] for i in range(block.height())]

        for l in matrix:
            for v in l:
                if v is not None:
                    if v < 0:
                        contains_negative = True

        return matrix, contains_negative

    @staticmethod
    def dijkstra(start_row_col, end_row_cols, block):
        sqrt2 = 1.4142

        class Grid:
            def __init__(self, matrix):
                self.map = matrix
                self.h = len(matrix)
                self.w = len(matrix[0])

            def _in_bounds(self, id):
                x, y = id
                return 0 <= x < self.h and 0 <= y < self.w

            def _passable(self, id):
                x, y = id
                return self.map[x][y] is not None

            def is_valid(self, id):
                return self._in_bounds(id) and self._passable(id)

            def neighbors(self, id):
                x, y = id
                results = [(x + 1, y), (x, y - 1), (x - 1, y), (x, y + 1),
                           (x + 1, y - 1), (x + 1, y + 1), (x - 1, y - 1), (x - 1, y + 1)]
                results = filter(self._in_bounds, results)
                results = filter(self._passable, results)
                return results

            def simple_cost(self, cur, nex):
                cx, cy = cur
                nx, ny = nex
                currV = self.map[cx][cy]
                offsetV = self.map[nx][ny]
                if cx == nx or cy == ny:
                    return (currV + offsetV) / 2
                else:
                    return sqrt2 * (currV + offsetV) / 2

        grid = Grid(block)
        end_row_cols = set(end_row_cols)

        frontier = queue.PriorityQueue()
        frontier.put((0, start_row_col))
        came_from = {}
        cost_so_far = {}

        if not grid.is_valid(start_row_col):
            return None, None

        came_from[start_row_col] = None
        cost_so_far[start_row_col] = 0

        current_node = None
        while not frontier.empty():
            current_cost, current_node = frontier.get()

            if current_node in end_row_cols:
                break

            for nex in grid.neighbors(current_node):
                new_cost = cost_so_far[current_node] + grid.simple_cost(current_node, nex)
                if nex not in cost_so_far or new_cost < cost_so_far[nex]:
                    cost_so_far[nex] = new_cost
                    frontier.put((new_cost, nex))
                    came_from[nex] = current_node

        if current_node in end_row_cols:
            least_cost = cost_so_far[current_node]
            path = []
            while current_node is not None:
                path.append(current_node)
                current_node = came_from[current_node]

            path.reverse()
            return path, least_cost
        else:
            return None, None

